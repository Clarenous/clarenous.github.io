---
layout: post
title: 24位真彩色转256色的流行色算法(C++)
date: 2017-01-06
categories: blog
tags: [C++]
description: 数据结构与STL
---

# [1]算法功能和基本思想 #

与8位的256色BMP 文件相比，24位真彩色BMP文件可以表示16777216种颜色。因此，将24位真彩色BMP文件转为256色BMP文件必然会损失大量的颜色信息。为了减少颜色信息的损失，我们需要合理地从24位真彩色文件中选择256种颜色作为8位文件的颜色表，并通过合理的颜色映射关系，把原来24位的一个像素点转为用8位表示256种颜色的某一个颜色。

通过查阅资料，我发现目前存在流行色算法、中位切分算法、八叉树算法等几种常用算法。我选择较为容易实现的流行色算法来完成本功能。

流行色算法的基本思想是：统计一个图片文件中出现次数次最多的256种颜色，把这256种颜色称为“流行色”，作为8位BMP文件的颜色表。由于网上查不到该算法的具体实现方法，因此我根据个人的理解设计了基于流行色算法的算法实现如下：

(1)	载入24位真彩色图片A ，获得A 的宽度，高度，像素矩阵起始地址指针。

(2)	根据A 的宽度、高度创建一个颜色深度为8位的新BMP文件B，其颜色表默认为256个灰度值。

(3)	通过合理的算法统计出A中出现次数最多的256种颜色，即流行色。

(4)	将选出的流行色写入B 的颜色表，按频度从高到低的顺序存放，提高接下来写入新像素时的速度。

(5)	建立B 的颜色表的灰度索引表，即一个按顺序存放256种颜色灰度值的数组。

(6)	遍历A 的像素矩阵，按灰度值相近程度(绝对值之差越小越相近)匹配对应的256色的颜色，写入B 的像素矩阵。

(7)	存储B ，得到24位真彩色BMP文件A 转化得到的256色BMP文件B 。
对于第(3)步筛选流行色的过程，还需要进一步解释。一开始我选择的方案是，用一个三维数组`RGB_COUNT[256][256][256] `来记录每种颜色的出现频度。统计时首先遍历一遍A 的像素矩阵，统计出各颜色的出现次数。再对这一三维数组按简单选择排序的思想做256趟简单选择，即可得到出现次数最多的256种颜色的数组下标`RGB_COUNT[i][j][k] `,而下标i、j、k即为颜色的RGB值。

而当程序实际运行时，往往几分钟的时间都不会产生运行结果。这使我意识到可能是这一方法的时间复杂度过高。经过分析，我发现，该过程平均需要进行4294967296次比较和移动。不考虑一切影响因素，假设计算机1纳秒完成一条操作，也需要40多秒才能完成该过程。可见，该算法并不可取。

于是，我又利用双向链表、栈的思想设计了另一种一边遍历A 的像素矩阵，一边选择256种流行色的算法。其思想是，用双向链表构建一个最多可存放256个结点的栈，每个结点包含一个数据域int data ，用来存储当前状态下流行色在`RGB_COUNT[16777216] `中的下标。而这些结点的存放是按照栈底流行色出现次数最多、栈顶流行色出现次数最少的顺序存放的。与此同时，利用int min_count 来记录栈中频度最低的流行色的出现次数。

每当遍历一个A 中的像素时，为该像素对应的颜色的统计次数加一，判断该颜色的出现次数是否大于或等于int min_count ，若大于或等于，则该颜色符合入栈的条件。至于入栈后该颜色应插入的位置，若该颜色已在栈中，根据颜色的频度将该颜色往栈底方向后移至合适的位置；若该颜色不在栈中，则将它放在频度恰好大于或等于它的颜色的前一个位置。插入结束后，若栈中的元素个数大于256个，则将栈顶元素出栈。

这样，当A 的所有像素遍历结束后，栈中就存放了从栈顶到栈底频度依次升高的256个流行色(A 本身的颜色不足256时，栈中元素个数不足256)的下标。对于每个下标popular来讲，分别做(popular & 0xff0000) / 65536，(popular & 0x00ff00) / 256，(popular & 0x0000ff)的位操作，就分别得到了RGB 值中的B,G,R 值。也就得到了256种流行色。
通过运行代码，我发现此时图片可以在1秒左右的时间内处理完毕。

# [2]算法时间复杂度分析 #
未能分析出准确的时间复杂度，估计当图像有n个像素时，时间复杂度为O(n)~O(n2) 。
